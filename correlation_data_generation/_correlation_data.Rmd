---
title: "correlation data"
author: "Martin Monkman"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(MASS)
library(mvtnorm)

```

## Data creation

This file creates a single table (tibble) with x-y pairs of varying correlation strengths.

The distributions of both X and Y variables are the same:

* mean = 100


## permutations on X


This approach creates and X variable ("myData") and then creates permutations on that

https://www.r-bloggers.com/2010/08/even-simpler-multivariate-correlated-simulations/

```{r}

# multivariate normal example using the MASS package


require(MASS)

#make this reproducible
set.seed(2)

#how many draws in our starting data set?
n <- 1e4

# how many draws do we want from this distribution?
drawCount <- 1e4

myData   <- rnorm(n, 5, .6)
yourData <- myData  + rnorm(n, 8, .25)
hisData  <- myData  + rnorm(n, 6, .4)
herData  <- hisData + rnorm(n, 8, .35)

ourData <- data.frame(myData, yourData, hisData, herData)

# now we have raw correlations in the 70s, 80s, and 90s. Funny how that
# works out
cor(ourData)

#build the mvrnorm and take draws
#this replaces all my normalizing and
#copula building in the previous example
myDraws <- mvrnorm(1e5, mu=mean(ourData),
             Sigma=cov(ourData)
             )
myDraws <- data.frame(myDraws)

#check the mean and sd
apply(myDraws, 2, mean)
apply(myDraws, 2, sd)

#let's look at the mean and standard dev of the starting data
apply(ourData, 2, mean)
apply(ourData, 2, sd)

# so myDraws contains the final draws
# let's check Kolmogorov-Smirnov between the starting data
# and the final draws

for (i in 1:ncol(ourData)){
   print(ks.test(myDraws[[i]], ourData[[i]]))
}

#look at the correlation matrices
cor(myDraws)
cor(ourData)

#it's fun to plot the variables and see if the PDFs line up
#It's a good sanity check. Using ggplot2 to plot

require(ggplot2)

# rearrange the data to be "tall" not "wide"
meltDraws <-melt(myDraws)
meltDraws$dataSource <- "simulated"
meltData <- melt(ourData)
meltData$dataSource <- "original"
plotData <- rbind(meltData, meltDraws)

qplot(value, colour=dataSource, data=plotData, geom="density")+ facet_wrap(~variable)


```

### another permutaion

This time it's hard coded variations (note different distributions)

https://www.youtube.com/watch?v=PejMY5rdT7A
https://statisticsglobe.com/generate-multivariate-random-data-r

```{r}
set.seed(354627)

x1 <- rnorm(1000)                 # Create random data
x2 <- rpois(1000, 2) + 0.5 * x1
x3 <- runif(1000) + 0.2 * x1 - 0.7 * x2
data1 <- data.frame(x1, x2, x3)
head(data1)         

cor(data1)

```




## Using {MASS} package

`MASS::mvrnorm()` function

mu = means
Sigma = correlation matrix

### 2x2


```{r}

set.seed(1)

data_x <- MASS::mvrnorm(n = 100,        # Create random data
                 mu = c(100, 100),  # mean values
                 Sigma = matrix(c(1, 0.5,
                                  0.5, 1),
                                nrow = 2))

head(data_x)                       # Head of random data

data_x <- as_tibble(data_x)

cor(data_x)



```


```{r}

set.seed(1)

data_x <- MASS::mvrnorm(n = 100,        # Create random data
                 mu = c(100, 100),  # mean values
                 Sigma = matrix(c(1, 0.8,
                                  0.8, 1),
                                nrow = 2))

head(data_x)                       # Head of random data

data_x <- as_tibble(data_x)

cor(data_x)



```




### 3x3


```{r}

data2 <- MASS::mvrnorm(n = 1000,        # Create random data
                 mu = c(0.5, 0, 10),
                 Sigma = matrix(c(1, 0.2, 0.3,
                                  0.2, 1, 0.6,
                                  0.3, 0.6, 1),
                                nrow = 3))
head(data2)                       # Head of random data

cor(data2)

```


repeat but with 3 variables all with mean of 100

```{r}

set.seed(1)

data2 <- MASS::mvrnorm(n = 1000,        # Create random data
                 mu = c(100, 100, 100),  # mean values
                 Sigma = matrix(c(1, 0.5, 0.0,
                                  0.5, 1, 0.6,
                                  0.0, 0.6, 1),
                                nrow = 3))

head(data2)                       # Head of random data

data2 <- as_tibble(data2)

cor(data2)



```




```{r}
data2 |> 
  rename("X" = V1, "R=0.5" = V2, "R=0.0" = V3) |> 
  pivot_longer(-X, names_to = "Y_vector", values_to = "Y_value") |> 
ggplot(aes(X, Y_value)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~Y_vector)

```



### 3x3 - another


https://www.r-bloggers.com/2021/05/how-to-generate-correlated-data-in-r/

```{r}

library(MASS)
library(tidyverse)
library(GGally)


set.seed(5)

# create the variance covariance matrix
sigma<-rbind(c(1,-0.8,-0.7), c(-0.8,1, 0.9), c(-0.7,0.9,1))

# create the mean vector
mu<-c(10, 5, 2) 

# generate the multivariate normal distribution
df<-as.data.frame(mvrnorm(n=1000, mu=mu, Sigma=sigma))

ggpairs(df)

```



### 5x5


```{r}

set.seed(1)

# THIS MATRIX FAILS
# 'Sigma' is not positive definite

corrmatrix <- matrix(c(1.0, 0.6, -0.2, 0.7, 0.1,
                       0.6, 1.0, 0.3, 0.5, -0.4,
                       -0.2, 0.3, 1.0, -0.1, 0.8,
                       0.7, 0.5, -0.1, 1.0, 0.2,
                       0.1, -0.4, 0.8, 0.2, 1.0),
                     nrow = 5)

#data5 <- MASS::mvrnorm(
#                  n = 100,        # Create random data
#                 mu = c(100, 100, 100, 100, 100),  # mean values
#                 Sigma = corrmatrix
#                 )
#
#head(data5)                       # Head of random data
#
#data5 <- as_tibble(data5)
#
#cor(data5)

corrmatrix_cp <- crossprod(corrmatrix)
corrmatrix_cp

tryCatch({
  chol(corrmatrix_cp)
  print("Matrix A is positive definite.")
}, error = function(e) {
  print("Matrix A is not positive definite.")
})

```

## {Matrix} package

This package has the ability to create a positive definite matrix

This allows us to create a 5x5 matrix that will work with the `MASS::mvrnorm()` function

https://cran.r-project.org/web/packages/Matrix/index.html


```{r}
## Ensure the Matrix package is installed
#if (!requireNamespace("Matrix", quietly = TRUE)) {
#  install.packages("Matrix")
#}
library(Matrix)

# Example of a matrix that might not be exactly positive definite
# Replace this with your actual matrix
my_matrix <- matrix(c(2, 1, 0, 0, 0,
                      1, 2, 1, 0, 0,
                      0, 1, 2, 1, 0,
                      0, 0, 1, 2, 1,
                      0, 0, 0, 1, 2), nrow=5, byrow=TRUE)

# Compute the nearest positive definite matrix
nearest_PD_matrix <- nearPD(my_matrix, corr = FALSE)$mat

# Display the result
print(nearest_PD_matrix)
```



```{r}
## REPEAT WITH MY MATRIX
corrmatrix <- matrix(c( 1.0, 0.9, 0.6, 0.3, 0.0,
                        0.9, 1.0, 0.3, 0.5, 0.3,
                        0.6, 0.3, 1.0, 0.6, 0.6,
                        0.3, 0.5, 0.6, 1.0, 0.8,
                        0.0, 0.3, 0.6, 0.8, 1.0),
                                nrow = 5)


my_matrix <- corrmatrix

# Compute the nearest positive definite matrix
nearest_PD_matrix <- nearPD(my_matrix, corr = FALSE)$mat

# Display the result
print(nearest_PD_matrix)
```

ok let's use that matrix as "Sigma" to create a set of data


```{r}
data6 <- MASS::mvrnorm(
                  n = 1000,        # Create random data
                 mu = c(100, 100, 100, 100, 100),  # mean values
                 Sigma = nearest_PD_matrix
                 )

head(data6)                       # Head of random data

data6 <- as_tibble(data6)

cor(data6)

```

```{r}

data6a <- data6 |> 
  rename("X" = V1, "R=0.8" = V2, "R=0.4" = V3, "R=0.2" = V4, "R=0.0" = V5) |> 
  pivot_longer(-X, names_to = "Y_vector", values_to = "Y_value") |> 
  mutate(Y_vector = as_factor(Y_vector))

data6a |> 
ggplot(aes(X, Y_value)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~Y_vector)

```




## one more

https://stackoverflow.com/questions/72894192/how-to-simulate-a-strong-correlation-of-data-with-r

```{r}
# Source - https://stackoverflow.com/a
# Posted by Zheyuan Li, modified by community. See post 'Timeline' for change history
# Retrieved 2025-11-14, License - CC BY-SA 4.0

## your current specification of marginal mean and marginal standard deviation
mean_mod.iq <- 120
mean_kid.score <- 45
sd_mod.iq <- 15
sd_kid.score <- 20

## introduce correlation coefficient between two variables
## coefficient must be between -1 and 1
corcoef <- 0.8
## the result covariance between two variables
covariance <- corcoef * sd_mod.iq * sd_kid.score

## the variance-covariance matrix
Sigma <- matrix(c(sd_mod.iq^2, covariance, covariance, sd_kid.score^2), nrow = 2)
#     [,1] [,2]
#[1,]  225  240
#[2,]  240  400

# Source - https://stackoverflow.com/a
# Posted by Zheyuan Li, modified by community. See post 'Timeline' for change history
# Retrieved 2025-11-14, License - CC BY-SA 4.0

xy <- MASS::mvrnorm(n = 500, mu = c(mean_mod.iq, mean_kid.score), Sigma = Sigma)
colnames(xy) <- c("mod.iq", "kid.score")
xydf <- data.frame(xy)
head(xydf)
#    mod.iq kid.score
#1 111.6211  33.26241
#2 114.4765  42.49280
#3 115.8160  47.57242
#4 121.8656  53.16578
#5 152.1459  89.60617
#6 107.4360  39.00345

plot(xydf)


# Source - https://stackoverflow.com/a
# Posted by Zheyuan Li, modified by community. See post 'Timeline' for change history
# Retrieved 2025-11-14, License - CC BY-SA 4.0

sapply(xydf, mean)  ## mean, you specified 120 and 45
#   mod.iq kid.score 
# 119.9499   44.4193 

sapply(xydf, sd)  ## standard error, you specified 15 and 20
#   mod.iq kid.score 
# 15.35214  20.16483 

```

my adds

```{r}

cor(xydf)

```



## package `{randcorr}`

generates

```{r}
set.seed(10)
randcorr::randcorr(p = 5)

set.seed(11)
randcorr::randcorr(p = 5)


```




---

## FINAL

```{r}

set.seed(1)

data2 <- MASS::mvrnorm(n = 100,        # Create random data
                 mu = c(100, 100, 100, 100),  # mean values
#                 Sigma = matrix(c(1, 0.8, 0.4, 0.0,
#                                  0.8, 1, 0.6, 0.4,
#                                  0.4, 0.6, 1, 0.4,
#                                  0.0, 0.4, 0.6, 1),
#                                nrow = 4))
                 Sigma = matrix(c(1, 0.9, 0.5, 0.0,
                                  0.9, 1, 0.6, 0.4,
                                  0.5, 0.6, 1, 0.4,
                                  0.0, 0.4, 0.6, 1),
                                nrow = 4))

head(data2)                       # Head of random data

data2 <- as_tibble(data2) 
data2

cor(data2)



```


```{r}
data2a <- data2 |> 
  rename("X" = V1, "R=0.9" = V2, "R=0.5" = V3, "R=0.0" = V4) |> 
  pivot_longer(-X, names_to = "Y_vector", values_to = "Y_value") |> 
  mutate(Y_vector = as_factor(Y_vector))

data2a |> 
ggplot(aes(X, Y_value)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~Y_vector)

```


, levels = c("X", "R=0.8", "R=0.4", "R=0.0")

```{r}
data2b <- data2 |> 
  mutate(
    V2 = V2 * -1,
    V3 = V3 * -1,
    V4 = V4 * -1
  ) |> 
  rename("X" = V1, "R=-0.9" = V2, "R=-0.5" = V3, "R=0.0" = V4) |> 
  
  pivot_longer(-X, names_to = "Y_vector", values_to = "Y_value") |> 
  mutate(Y_vector = as_factor(Y_vector))


ggplot(data2b, aes(X, Y_value)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~Y_vector)

```


As single facet


```{r}
data2c <- data2 |> 
  mutate(
    "R = -0.9" = 100 - (V2  - 100),
    "R = -0.5" = 100 - (V3  - 100)
  ) |> 
#  rename("X" = V1, "R=-0.8" = V2, "R=-0.4" = V3, "R=0.0" = V4) |> 
  rename("X" = V1, "R = 0.9" = V2, "R = 0.5" = V3, "R = 0.0" = V4) |> 
  pivot_longer(-X, names_to = "Y_vector", values_to = "Y_value") |> 
  mutate(Y_vector = as_factor(Y_vector))

data2c |> 
ggplot(aes(X, Y_value)) +
  geom_point() +
#  geom_smooth(method = "lm") +
  facet_wrap(~Y_vector) +
  labs(
    y = "Y"
  )

#ggsave("correlation_facets.jpg")
```


```{r}
data2d <- data2 |> 
  mutate(
    "R^2 = 0.81 (negative)" = 100 - (V2  - 100),
    "R^2 = 0.25 (negative)" = 100 - (V3  - 100)
  ) |> 
#  rename("X" = V1, "R=-0.8" = V2, "R=-0.4" = V3, "R=0.0" = V4) |> 
  rename("X" = V1, "R^2 = 0.81" = V2, "R^2 = 0.25" = V3, "R^2 = 0.0" = V4) |> 
  pivot_longer(-X, names_to = "Y_vector", values_to = "Y_value") |> 
  mutate(Y_vector = as_factor(Y_vector))


data2d |> 
ggplot(aes(X, Y_value)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~Y_vector) +
  labs(
    y = "Y"
  )

#ggsave("regression_facets.jpg")

```

